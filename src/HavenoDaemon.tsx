/**
 * These imports are generated by protoc-gen-grpc-web (created with `sudo make install-plugin` in grpc-web) using the following command:
 *
 * `protoc -I=./ *.proto --js_out=import_style=commonjs:./ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:./`
 */
const {GetVersionRequest, WalletsClient, OffersClient} = require('./grpc_grpc_web_pb.js');
const {GetVersionClient, GetBalancesRequest, GetOffersRequest} = require('./grpc_pb.js');

/**
 * Haveno daemon client using gRPC.
 */
class HavenoDaemon {
  
  // instance variables
  _url: string;
  _password?: string;
  _getVersionClient: any;
  _walletsClient?: any;
  _offersClient?: any;
  
  /**
   * Construct a client connected to a Haveno daemon.
   * 
   * @param {string} url - Haveno daemon url
   * @param {string} password - Haveno daemon password if applicable 
   */
  constructor(url: string, password?: string) {
    this._url = url;
    this._password = password;
  }
  
  /**
   * Get the Haveno version.
   * 
   * @return {string} the Haveno daemon version 
   */
  async getVersion(): Promise<string> {
    if (!this._getVersionClient) this._getVersionClient = new GetVersionClient(this._url);
    let request = new GetVersionRequest();
    let that = this;
    return new Promise(function(resolve, reject) {
      that._getVersionClient.getVersion(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else resolve(response.getVersion());
      });
    });
  }
  
  /**
   * Get the user's balances.
   * 
   * @return {HavenoBalances} the user's balances
   */
  async getBalances(): Promise<HavenoBalances> {
    if (!this._walletsClient) this._walletsClient = new WalletsClient(this._url);
    let request = new GetBalancesRequest();
    let that = this;
    return new Promise(function(resolve, reject) {
      that._walletsClient.getBalances(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else resolve(new HavenoBalances(
            BigInt(response.getBalances().getXmr().getUnlockedbalance()),
            BigInt(response.getBalances().getXmr().getLockedbalance()),
            BigInt(response.getBalances().getXmr().getReservedofferbalance()),
            BigInt(response.getBalances().getXmr().getReservedtradebalance())));
      });
    });
  }
  
  /**
   * Get available offers to buy or sell XMR.
   * 
   * @param {string} direction - one of "BUY" or "SELL"
   * 
   * @return {HavenoOffer[]} available offers
   */
  async getOffers(direction: string): Promise<HavenoOffer[]> {
    if (!this._offersClient) this._offersClient = new OffersClient(this._url);
    let request = new GetOffersRequest()
            .setDirection(direction)
            .setCurrencycode("XMR");
    let that = this;
    return new Promise(function(resolve, reject) {
      that._offersClient.getOffers(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else {
          let offers: HavenoOffer[] = [];
          for (let offer of response.getOffersList()) offers.push(grpcOfferToHavenoOffer(offer));
          resolve(offers);
        }
      });
    });
  }
  
  /**
   * Get user's created offers to buy or sell XMR.
   * 
   * @param {string} direction - one of "BUY" or "SELL"
   * 
   * @return {HavenoOffer[]} created offers
   */
  async getMyOffers(direction: string): Promise<HavenoOffer[]> {
    if (!this._offersClient) this._offersClient = new OffersClient(this._url);
    let request = new GetOffersRequest()
            .setDirection(direction)
            .setCurrencycode("XMR");
    let that = this;
    return new Promise(function(resolve, reject) {
      that._offersClient.getMyOffers(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else {
          let offers: HavenoOffer[] = [];
          for (let offer of response.getOffersList()) offers.push(grpcOfferToHavenoOffer(offer));
          resolve(offers);
        }
      });
    });
  }
}

class HavenoBalances {
  unlockedBalance: bigint;
  lockedBalance: bigint;
  reservedOfferBalance: bigint;
  reservedTradeBalance: bigint;
  constructor(unlockedBalance: bigint,
        lockedBalance: bigint,
        reservedOfferBalance: bigint,
        reservedTradeBalance: bigint) {
    this.unlockedBalance = unlockedBalance;
    this.lockedBalance = lockedBalance;
    this.reservedOfferBalance = reservedOfferBalance;
    this.reservedTradeBalance = reservedTradeBalance;
  }
}

class HavenoOffer {
  id: string;
  direction: string;
  price: bigint;
  useMarketBasedPrice: boolean;
  marketPriceMargin: number;
  amount: bigint;
  minAmount: bigint;
  volume: bigint;
  minVolume: bigint;
  buyerSecurityDeposit: bigint;
  triggerPrice: bigint;
  isCurrencyForMakerFeeBtc: boolean;
  paymentAccountId: string;
  paymentMethodId: string;
  paymentMethodShortName: string;
  baseCurrencyCode: string;
  counterCurrencyCode: string;
  date: bigint;
  state: string;
  sellerSecurityDeposit: bigint;
  offerFeePaymentTxId: string;
  txFee: bigint;
  makerFee: bigint;
  constructor(id: string,
        direction: string,
        price: bigint,
        useMarketBasedPrice: boolean,
        marketPriceMargin: number,
        amount: bigint,
        minAmount: bigint,
        volume: bigint,
        minVolume: bigint,
        buyerSecurityDeposit: bigint,
        triggerPrice: bigint,
        isCurrencyForMakerFeeBtc: boolean,
        paymentAccountId: string,
        paymentMethodId: string,
        paymentMethodShortName: string,
        baseCurrencyCode: string,
        counterCurrencyCode: string,
        date: bigint,
        state: string,
        sellerSecurityDeposit: bigint,
        offerFeePaymentTxId: string,
        txFee: bigint,
        makerFee: bigint,) {
    this.id = id;
    this.direction = direction;
    this.price = price;
    this.useMarketBasedPrice = useMarketBasedPrice;
    this.marketPriceMargin = marketPriceMargin;
    this.amount = amount;
    this.minAmount = minAmount;
    this.volume = volume;
    this.minVolume = minVolume;
    this.buyerSecurityDeposit = buyerSecurityDeposit;
    this.triggerPrice = triggerPrice;
    this.isCurrencyForMakerFeeBtc = isCurrencyForMakerFeeBtc;
    this.paymentAccountId = paymentAccountId;
    this.paymentMethodId = paymentMethodId;
    this.paymentMethodShortName = paymentMethodShortName;
    this.baseCurrencyCode = baseCurrencyCode;
    this.counterCurrencyCode = counterCurrencyCode;
    this.date = date;
    this.state = state;
    this.sellerSecurityDeposit = sellerSecurityDeposit;
    this.offerFeePaymentTxId = offerFeePaymentTxId;
    this.txFee = txFee;
    this.makerFee = makerFee;
  }
}

function grpcOfferToHavenoOffer(offer: any) {
  return new HavenoOffer(
      offer.getId(),
      offer.getDirection(),
      offer.getPrice(),
      offer.getUsemarketbasedprice(),
      offer.getMarketpricemargin(),
      offer.getAmount(),
      offer.getMinamount(),
      offer.getVolume(),
      offer.getMinvolume(),
      offer.getBuyersecuritydeposit(),
      offer.getTriggerprice(),
      offer.getIscurrencyformakerfeebtc(),
      offer.getPaymentaccountid(),
      offer.getPaymentmethodid(),
      offer.getPaymentmethodshortname(),
      offer.getBasecurrencycode(),
      offer.getCountercurrencycode(),
      offer.getDate(),
      offer.getState(),
      offer.getSellersecuritydeposit(),
      offer.getOfferfeepaymenttxid(),
      offer.getTxfee(),
      offer.getMakerfee()
  );
}

export {HavenoDaemon, HavenoBalances, HavenoOffer};