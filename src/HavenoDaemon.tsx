/**
 * These imports are generated by protoc-gen-grpc-web (created with `sudo make install-plugin` in grpc-web) using the following command:
 *
 * `protoc -I=./ *.proto --js_out=import_style=commonjs:./ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:./`
 */
const {GetVersionRequest, WalletsClient, OffersClient} = require('./grpc_grpc_web_pb.js');
const {GetVersionClient, GetBalancesRequest, GetOffersRequest} = require('./grpc_pb.js');

/**
 * Haveno daemon client using gRPC.
 */
class HavenoDaemon {
  
  // instance variables
  _url: string;
  _password?: string;
  _getVersionClient: any;
  _walletsClient?: any;
  _offersClient?: any;
  
  /**
   * Construct a client connected to a Haveno daemon.
   * 
   * @param {string} url - Haveno daemon url
   * @param {string} password - Haveno daemon password if applicable 
   */
  constructor(url: string, password?: string) {
    this._url = url;
    this._password = password;
  }
  
  /**
   * Get the Haveno version.
   * 
   * @return {string} the Haveno daemon version 
   */
  async getVersion(): Promise<string> {
    if (!this._getVersionClient) this._getVersionClient = new GetVersionClient(this._url);
    let request = new GetVersionRequest();
    let that = this;
    return new Promise(function(resolve, reject) {
      that._getVersionClient.getVersion(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else resolve(response.getVersion());
      });
    });
  }
  
  /**
   * Get the user's balances.
   * 
   * @return {HavenoBalances} the user's balances
   */
  async getBalances(): Promise<HavenoBalances> {
    if (!this._walletsClient) this._walletsClient = new WalletsClient(this._url);
    let request = new GetBalancesRequest();
    let that = this;
    return new Promise(function(resolve, reject) {
      that._walletsClient.getBalances(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else resolve(new HavenoBalances(
            BigInt(response.getBalances().getXmr().getUnlockedbalance()),
            BigInt(response.getBalances().getXmr().getLockedbalance()),
            BigInt(response.getBalances().getXmr().getReservedofferbalance()),
            BigInt(response.getBalances().getXmr().getReservedtradebalance())));
      });
    });
  }
  
  /**
   * Get available offers.
   * 
   * @param {string} direction - one of "BUY" or "SELL"
   * @param {string} currencyCode - the currency being bought or sold, e.g. "ETH"
   * 
   * @return {HavenoOffer[]} available offers
   */
  async getOffers(direction: string, currencyCode: string): Promise<HavenoOffer[]> {
    if (!this._offersClient) this._offersClient = new OffersClient(this._url);
    let request = new GetOffersRequest()
            .setDirection(direction)
            .setCurrencycode(currencyCode);
    let that = this;
    return new Promise(function(resolve, reject) {
      that._offersClient.getOffers(request, {password: that._password}, function(err: any, response: any) {
        if (err) reject(err);
        else {
          let offers: HavenoOffer[] = [];
          for (let offer of response.getOffersList()) {
            offers.push(new HavenoOffer(
                offer.getId(),
                offer.getDirection(),
                offer.getPrice(),
                offer.getUsemarketbasedprice(),
                offer.getMarketpricemargin(),
                offer.getAmount(),
                offer.getMinamount(),
                offer.getVolume(),
                offer.getMinvolume(),
                offer.getBuyersecuritydeposit(),
                offer.getTriggerprice(),
                offer.getIscurrencyformakerfeebtc(),
                offer.getPaymentaccountid(),
                offer.getPaymentmethodid(),
                offer.getPaymentmethodshortname(),
                offer.getBasecurrencycode(),
                offer.getCountercurrencycode(),
                offer.getDate(),
                offer.getState(),
                offer.getSellersecuritydeposit(),
                offer.getOfferfeepaymenttxid(),
                offer.getTxfee(),
                offer.getMakerfee()
            ));
          }
          resolve(offers);
        }
      });
    });
  }
}

class HavenoBalances {
  unlockedBalance: bigint;
  lockedBalance: bigint;
  reservedOfferBalance: bigint;
  reservedTradeBalance: bigint;
  constructor(unlockedBalance: bigint,
        lockedBalance: bigint,
        reservedOfferBalance: bigint,
        reservedTradeBalance: bigint) {
    this.unlockedBalance = unlockedBalance;
    this.lockedBalance = lockedBalance;
    this.reservedOfferBalance = reservedOfferBalance;
    this.reservedTradeBalance = reservedTradeBalance;
  }
}

class HavenoOffer {
  id: string;
  direction: string;
  price: bigint;
  useMarketBasedPrice: boolean;
  marketPriceMargin: number;
  amount: bigint;
  minAmount: bigint;
  volume: bigint;
  minVolume: bigint;
  buyerSecurityDeposit: bigint;
  triggerPrice: bigint;
  isCurrencyForMakerFeeBtc: boolean;
  paymentAccountId: string;
  paymentMethodId: string;
  paymentMethodShortName: string;
  baseCurrencyCode: string;
  counterCurrencyCode: string;
  date: bigint;
  state: string;
  sellerSecurityDeposit: bigint;
  offerFeePaymentTxId: string;
  txFee: bigint;
  makerFee: bigint;
  constructor(id: string,
        direction: string,
        price: bigint,
        useMarketBasedPrice: boolean,
        marketPriceMargin: number,
        amount: bigint,
        minAmount: bigint,
        volume: bigint,
        minVolume: bigint,
        buyerSecurityDeposit: bigint,
        triggerPrice: bigint,
        isCurrencyForMakerFeeBtc: boolean,
        paymentAccountId: string,
        paymentMethodId: string,
        paymentMethodShortName: string,
        baseCurrencyCode: string,
        counterCurrencyCode: string,
        date: bigint,
        state: string,
        sellerSecurityDeposit: bigint,
        offerFeePaymentTxId: string,
        txFee: bigint,
        makerFee: bigint,) {
    this.id = id;
    this.direction = direction;
    this.price = price;
    this.useMarketBasedPrice = useMarketBasedPrice;
    this.marketPriceMargin = marketPriceMargin;
    this.amount = amount;
    this.minAmount = minAmount;
    this.volume = volume;
    this.minVolume = minVolume;
    this.buyerSecurityDeposit = buyerSecurityDeposit;
    this.triggerPrice = triggerPrice;
    this.isCurrencyForMakerFeeBtc = isCurrencyForMakerFeeBtc;
    this.paymentAccountId = paymentAccountId;
    this.paymentMethodId = paymentMethodId;
    this.paymentMethodShortName = paymentMethodShortName;
    this.baseCurrencyCode = baseCurrencyCode;
    this.counterCurrencyCode = counterCurrencyCode;
    this.date = date;
    this.state = state;
    this.sellerSecurityDeposit = sellerSecurityDeposit;
    this.offerFeePaymentTxId = offerFeePaymentTxId;
    this.txFee = txFee;
    this.makerFee = makerFee;
  }
}

export {HavenoDaemon, HavenoBalances, HavenoOffer};